#!/usr/bin/perl -w
# retail: a program to run periodically to print the latest lines of a 
# potentially rotated log file.  Keeps state between runs - state includes
# the last read byte offset of the file, and the next run seeks to that offset.
#
# 2012-07-31 - Rowan Littell

use strict;
use Getopt::Std;
use Fcntl;
use NDBM_File;
use File::Basename;
use Digest::SHA1 qw /sha1_hex sha1_base64/;

my $STATEPATH = "/tmp";
my $DEBUG = 0;

sub usage() {
  print "Usage: retail [-d] [-h] [-s <state dir>] -f <logfile pattern>\n\n";
  print "retail is a log file tailer in the spirit of logtail that keeps state in\n";
  print "an NDBM file and can follow all log files matching a regular expression\n";
  print "pattern.  For example, to follow logs created with a time stamp suffix\n";
  print "of the form access.YYYY-MM-DD (note the escapes for shell):\n\n";
  print "    retail -f /var/log/apache/access.\\\\d{4}-\\\\d{2}-\\\\d{2}\n\n";
  print "retail compares the file name of the log file (but NOT any parts of the path)\n";
  print "to the regular expression when selecting files to follow.\n";
}

# return a list of files to process, sorted by ctime
# ARGS:
#  $filepattern: full path name, of which the last component may be a
#    regular expression to match multiple files
# RETURNS:
#  @files: a list of individual file names (full path), sorted by ctime
sub getfiles ($) {
  my ($filepattern) = @_;
  my $dirname = dirname ($filepattern);
  my $pattern = basename ($filepattern);
  my (@files, %stat);

  opendir (D, $dirname) || return (@files);
  my @dirfiles = readdir (D);
  closedir (D);
  print STDERR "DEBUG: matching pattern: $pattern\n" if ($DEBUG);
  foreach my $file (@dirfiles) {
    if ($file =~ /^$pattern$/) {
      push @files, "$dirname/$file";
      $stat{"$dirname/$file"} = (stat ("$dirname/$file"))[10];
    }
  }

  return (sort { $stat{$a} <=> $stat{$b} } @files);
}

################################################################################

MAIN:
{
  my (%opts, $filepattern, %state, %touched, %handles);

  # -d: turn on debugging output
  # -f <filepattern>: process these file patterns
  # -h: print usage
  # -s <state file path>: directory in which to save state files
  getopts('df:hs:', \%opts);

  if ($opts{'h'}) {
    usage();
    exit;
  }

  $DEBUG = 1 if ($opts{'d'});
  $STATEPATH = $opts{'s'} if ($opts{'s'});

  if ($opts{'f'}) {
    $filepattern = $opts{'f'};
  } else {
    die "Need file pattern!\n";
  }

  # To avoid multiple instances of retail clobbering each other's state
  # files, we use a unique state file generated by the SHA-1 hash of the
  # given file pattern, if given a state path that's a directory.  If
  # otherwise, check that dirname of path is a directory and assume the
  # state path is the file name.
  my $statefile;
  if (-d $STATEPATH) {
    $statefile = "$STATEPATH/retail-" . sha1_hex($filepattern);
  } else {
    my $dirname = dirname ($STATEPATH);
    if (-d $dirname) {
      $statefile = $STATEPATH;
    } else {
      die "Cannot access state file: $!\n";
    }
  }

  # open the state file
  tie (%state, 'NDBM_File', $statefile, O_RDWR|O_CREAT, 0666) || die "$statefile: $!\n";

  # get list of files to process
  my @files_to_process = getfiles ($filepattern);

  # open filehandles for all files before processing in case some
  # files go away while we're processing others
  foreach my $file (@files_to_process) {
    my $fh;
    if (sysopen ($fh, $file, O_RDONLY)) {
      $handles{$file} = $fh;
    } else {
      print STDERR "DEBUG: sysopen failed on $file: $!\n" if ($DEBUG);
    }
  }

  foreach my $file (@files_to_process) {

    # start at the beginning of the file; if offset defined in state file,
    # use that unless the offset is greater than the current file size,
    # indicating that the file has been truncated and rewritten.
    my $offset = 0;
    if (defined ($state{"OFFSET:$file"})) {
      my $fsize = (stat ($file))[7];
      if ($fsize >= $state{"OFFSET:$file"}) {
        $offset = $state{"OFFSET:$file"};
      }
    }

    print STDERR "DEBUG: open $file: $offset\n" if ($DEBUG);

    # if file has a previously opened file handle, process it
    # otherwise continue to next file
    if (!defined ($handles{$file})) {
      print STDERR "DEBUG: no file handle for $file\n" if ($DEBUG);
      next;
    }

    # seek, read/print, and close file
    my $fh = $handles{$file};
    sysseek ($fh, $offset, 0);
    my $line;
    while (my $bytes = sysread ($fh, $line, 1024)) {
      if ($DEBUG) {
        if ($line !~ /\n$/) {
          print STDERR '.';
        } else {
          print STDERR '+';
        }
      }
      $offset += $bytes;
      print "$line";
    }
    close ($fh);

    # save offset for next run
    $state{"OFFSET:$file"} = $offset;

    # we saw this file (used later for cleaning up state file)
    $touched{$file} = 1;

    print STDERR "\nDEBUG: close $file: $offset\n" if ($DEBUG);
  }

  # clean up the state file - remove entries for files that are no longer here
  foreach my $key (keys %state) {
    my (undef, $file) = (split (/:/, $key, 2));
    if (!defined ($touched{$file})) {
      print STDERR "DEBUG: remove $file\n" if ($DEBUG);
      delete ($state{$key});
    }
  }

  # close up shop
  untie (%state);
  exit 0;
}
